# Defining Services
- Building **requirements** for a project ask the questiosn:
    - who? - user, developers and stakeholders of app (who is being affected)
    - what? - main areas of functionality of app but it has to be clear. 
    - why? - reason for needing the system.
    - when? - timeline for users and developers
    - how? - how will the system work? number of users at a time? amount of data?
        - average payload size of service requests? latency requirements?
        - where users are
- **Qualatative requirements**:
- Roles represent the goal of a user. 
    - However, it can also be a microservice talking to another service
    - brainstorm roles of what users might do and then group together ones that belong to a specific action = role
    - **Persona** - a typical person who takes a role.
        - tells a story about that person and what they do
    - **User stories** - describe what the user wants the app to do and why the want to do it
        - **INVEST** criteria. evaluate user stories
            - Independent, Negotiable, Valuable, Estimatable, Small, Testable
- **Quantitative requirements** - measureable data based on constraints: time, finance, people
    - availability (accessibility), latency (time), throughput (durability, how much we can handle)
- **Key Performance Indicators (KPIs)** - measure success of product, app
    - for business: ROI, EBIT, Employee turnover, Customer churn
    - for tech: Page view, User registration, Clickthroughs, Checkouts
    - KPI's indicate if you're on track to acheive the goal
    - Need to define KPIs that mean success and signs that we're reaching the goal
    - KPIs must be **SMART**
        - Specific (more detail better), Measurable (know steps to reach objective), Achievable (attainable), Relevant (make sure it matters and is benefitial), Time-based (due dates, time available)
- **Service Level Indicators** - measurement of features of a service
    - Error rate, throughput, latency
    - must be countable/measureable and bound by time
        - Good to use percentile metrics for SLIs
- **Service Level Objectives** - agreed target of values for a measurement from an SLI
    - should improve user experience
    - shouldn't be too ambitious and out of reach.
        - _attainable_ and reasonable within costs
    - divide the SLO into parts for more performance gauge
        - 50% will be complete within 100 milliseconds
    - start with lower SLOS and something simple
    - don't deal in absolutes (100%)
    - don't have too many SLOs. only need to cover the key app attributes (features users care about)
- **Service Level Agreements** - agreement between service provider and consumer
    - service provider defines responsibilities and consequences if service not met
    - aka. a contract between the provider and the customer
        - better to be conservative with SLAs
            - there should be some saftey or threshold. lower than the SLO
- **NOTE:** - user experience isn't measureable or time bound, thus it's not a good KPI
    - user story = description of a feature written from the user's POV
# Microservice Design and Architecture
- **Microservices** = divide large program into independent services
    - this enables teams to work together better and faster
    - App Engine, Cloud Run, Kubernetes Engine, Cloud Functions help with building microservices 
    - Each service needs to have its **own** datastore for independence
    - better for scaling, logging errors, innovating, use different langauges for different services
    - Challanges: hard to define clear boundaries between services
        - more complex infrastructure between services: latency, security, different versions
        - backward compatibility as services might update
    - Microservices for an application should developed internalyl and be exposed through an API
        - The next layer should be the architectual layer where apps should be User Interfaces (web, iOS, android)
            - Last layer: Isolate services that provide data sharing by securing it with authentication
    - **Stateful services** (service connected to database) - harder to scale, upgrade, need to backup
        - avoid storign shared state in-memory on servers
            - this requries sticky sessions for the load balancer, meaning requests from one client go to the same server instance aka. **session affinity**
            - messes up elastic autoscaling
            - to fix use stateful services like Datastore or CloudSQL. then cache data for faster access speeds using Memorystore
                - allows for load balancer to scale backend and keep up with demand
    - **Stateless services** - easier to scale, update versions, and deploy
- **Twelve-Factor App** - 